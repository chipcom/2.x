#include 'function.ch'

////* 31.12.20 определить, является ли данный день рабочим днём
Function is_work_day(mdate)
    Local iy, im, m, d, y, am, fl := .t.
    Static arr_holiday := {;
        {2013,{;
            { 1,{1,2,3,4,5,6,7,8,12,13,19,20,26,27}},;
            { 2,{2,3,9,10,16,17,23,24}},;
            { 3,{2,3,8,9,10,16,17,23,24,30,31}},;
            { 4,{6,7,13,14,20,21,27,28}},;
            { 5,{1,2,3,4,5,9,10,11,12,18,19,25,26}},;
            { 6,{1,2,8,9,12,15,16,22,23,29,30}},;
            { 7,{6,7,13,14,20,21,27,28}},;
            { 8,{3,4,10,11,17,18,24,25,31}},;
            { 9,{1,7,8,14,15,21,22,28,29}},;
            {10,{5,6,12,13,19,20,26,27}},;
            {11,{2,3,4,9,10,16,17,23,24,30}},;
            {12,{1,7,8,14,15,21,22,28,29}}};
        },;
        {2014,{;
            { 1,{1,2,3,4,5,6,7,8,11,12,18,19,25,26}},;
            { 2,{1,2,8,9,15,16,22,23}},;
            { 3,{1,2,8,9,10,15,16,22,23,29,30}},;
            { 4,{5,6,12,13,19,20,26,27}},;
            { 5,{1,2,3,4,9,10,11,17,18,24,25,31}},;
            { 6,{1,7,8,12,13,14,15,21,22,28,29}},;
            { 7,{5,6,12,13,19,20,26,27}},;
            { 8,{2,3,9,10,16,17,23,24,30,31}},;
            { 9,{6,7,13,14,20,21,27,28}},;
            {10,{4,5,11,12,18,19,25,26}},;
            {11,{1,2,3,4,8,9,15,16,22,23,29,30}},;
            {12,{6,7,13,14,20,21,27,28}}};
        },;
        {2015,{;
            { 1,{1,2,3,4,5,6,7,8,9,10,11,17,18,24,25,31}},;
            { 2,{1,7,8,14,15,21,22,23,28}},;
            { 3,{1,7,8,9,14,15,21,22,28,29}},;
            { 4,{4,5,11,12,18,19,25,26}},;
            { 5,{1,2,3,4,9,10,11,16,17,23,24,30,31}},;
            { 6,{6,7,12,13,14,20,21,27,28}},;
            { 7,{4,5,11,12,18,19,25,26}},;
            { 8,{1,2,8,9,15,16,22,23,29,30}},;
            { 9,{5,6,12,13,19,20,26,27}},;
            {10,{3,4,10,11,17,18,24,25,31}},;
            {11,{1,4,7,8,14,15,21,22,28,29}},;
            {12,{5,6,12,13,19,20,26,27}}};
        },;
        {2016,{;
            { 1,{1,2,3,4,5,6,7,8,9,10,16,17,23,24,30,31}},;
            { 2,{6,7,13,14,21,22,23,27,28}},;
            { 3,{5,6,7,8,12,13,19,20,26,27}},;
            { 4,{2,3,9,10,16,17,23,24,30}},;
            { 5,{1,2,3,7,8,9,14,15,21,22,28,29}},;
            { 6,{4,5,11,12,13,18,19,25,26}},;
            { 7,{2,3,9,10,16,17,23,24,30,31}},;
            { 8,{6,7,13,14,20,21,27,28}},;
            { 9,{3,4,10,11,17,18,24,25}},;
            {10,{1,2,8,9,15,16,22,23,29,30}},;
            {11,{4,5,6,12,13,19,20,26,27}},;
            {12,{3,4,10,11,17,18,24,25,31}}};
        },;
        {2017,{;
            { 1,{1,2,3,4,5,6,7,8,14,15,21,22,28,29}},;
            { 2,{4,5,11,12,18,19,23,24,25,26}},;
            { 3,{4,5,8,11,12,18,19,25,26}},;
            { 4,{1,2,8,9,15,16,22,23,29,30}},;
            { 5,{1,6,7,8,9,13,14,20,21,27,28}},;
            { 6,{3,4,10,11,12,17,18,24,25}},;
            { 7,{1,2,8,9,15,16,22,23,29,30}},;
            { 8,{5,6,12,13,19,20,26,27}},;
            { 9,{2,3,9,10,16,17,23,24,30}},;
            {10,{1,7,8,14,15,21,22,28,29}},;
            {11,{4,5,6,11,12,18,19,25,26}},;
            {12,{2,3,9,10,16,17,23,24,30,31}}};
        },;
        {2018,{;
            { 1,{1,2,3,4,5,6,7,8,13,14,20,21,27,28}},;
            { 2,{3,4,10,11,17,18,23,24,25}},;
            { 3,{3,4,8,9,10,11,17,18,24,25,31}},;
            { 4,{1,7,8,14,15,21,22,29,30}},;
            { 5,{1,2,5,6,9,12,13,19,20,26,27}},;
            { 6,{2,3,10,11,12,16,17,23,24,30}},;
            { 7,{1,7,8,14,15,21,22,28,29}},;
            { 8,{4,5,11,12,18,19,25,26}},;
            { 9,{1,2,8,9,15,16,22,23,29,30}},;
            {10,{6,7,13,14,20,21,27,28}},;
            {11,{3,4,5,10,11,17,18,24,25}},;
            {12,{1,2,8,9,15,16,22,23,30,31}}};
        },;
        {2019,{;
            { 1,{1,2,3,4,5,6,7,8,12,13,19,20,26,27}},;
            { 2,{2,3,9,10,16,17,23,24}},;
            { 3,{2,3,8,9,10,16,17,23,24,30,31}},;
            { 4,{6,7,13,14,20,21,27,28}},;
            { 5,{1,2,3,4,5,9,10,11,12,18,19,25,26}},;
            { 6,{1,2,8,9,12,15,16,22,23,29,30}},;
            { 7,{6,7,13,14,20,21,27,28}},;
            { 8,{3,4,10,11,17,18,24,25,31}},;
            { 9,{1,7,8,14,15,21,22,28,29}},;
            {10,{5,6,12,13,19,20,26,27}},;
            {11,{2,3,4,9,10,16,17,23,24,30}},;
            {12,{1,7,8,14,15,21,22,28,29}}};
        },;
        {2020,{;
            { 1,{1,2,3,4,5,6,7,8,11,12,18,19,25,26}},;
            { 2,{1,2,8,9,15,16,22,23,24,29}},;
            { 3,{1,7,8,9,14,15,21,22,28,29}},;
            { 4,{4,5,11,12,18,19,25,26}},;
            { 5,{1,2,3,4,5,9,10,11,16,17,23,24,30,31}},;
            { 6,{6,7,12,13,14,20,21,27,28}},;
            { 7,{4,5,11,12,18,19,25,26}},;
            { 8,{1,2,8,9,15,16,22,23,29,30}},;
            { 9,{5,6,12,13,19,20,26,27}},;
            {10,{3,4,10,11,17,18,24,25,31}},;
            {11,{1,4,7,8,14,15,21,22,28,29}},;
            {12,{5,6,12,13,19,20,26,27}}};
        },;
        {2021,{;
            { 1,{1,2,3,4,5,6,7,8,9,10,16,17,23,24,30,31}},;
            { 2,{6,7,13,14,21,22,23,27,28}},;
            { 3,{6,7,8,13,14,20,21,27,28}},;
            { 4,{3,4,10,11,17,18,24,25}},;
            { 5,{1,2,3,8,9,10,15,16,22,23,29,30}},;
            { 6,{5,6,12,13,14,19,20,26,27}},;
            { 7,{3,4,10,11,17,18,24,25,31}},;
            { 8,{1,7,8,14,15,21,22,28,29}},;
            { 9,{4,5,11,12,18,19,25,26}},;
            {10,{2,3,9,10,16,17,23,24,30,31}},;
            {11,{4,5,6,7,13,14,20,21,27,28}},;
            {12,{4,5,11,12,18,19,25,26,31}}};
        },;
        {2022,{;
            { 1,{1,2,3,4,5,6,7,8,9,15,16,22,23,29,30}},;
            { 2,{5,6,12,13,19,20,23,26,27}},;
            { 3,{6,7,8,12,13,19,20,26,27}},;
            { 4,{2,3,9,10,16,17,23,24,30}},;
            { 5,{1,2,3,7,8,9,10,14,15,21,22,28,29}},;
            { 6,{4,5,11,12,13,18,19,25,26}},;
            { 7,{2,3,9,10,16,17,23,24,30,31}},;
            { 8,{6,7,13,14,20,21,27,28}},;
            { 9,{3,4,10,11,17,18,24,25}},;
            {10,{1,2,8,9,15,16,22,23,29,30}},;
            {11,{4,5,6,12,13,19,20,26,27}},;
            {12,{3,4,10,11,17,18,24,25,31}}};
        },;
          {2023,{;
            { 1,{1,2,3,4,5,6,7,8,14,15,21,22,28,29}},;
            { 2,{4,5,11,12,18,19,23,24,25,26}},;
            { 3,{4,5,8,11,12,18,19,25,26}},;
            { 4,{1,2,8,9,15,16,22,23,29,30}},;
            { 5,{1,6,7,8,9,13,14,20,21,27,28}},;
            { 6,{3,4,10,11,12,17,18,24,25}},;
            { 7,{1,2,8,9,15,16,22,23,29,30}},;
            { 8,{5,6,12,13,19,20,26,27}},;
            { 9,{2,3,9,10,16,17,23,24,30}},;
            {10,{1,7,8,14,15,21,22,28,29}},;
            {11,{4,5,6,11,12,18,19,25,26}},;
            {12,{2,3,9,10,16,17,23,24,30,31}}};
        };
    }


    m := month(mdate)
    d := day(mdate)
    y := year(mdate)
    if (iy := ascan(arr_holiday, {|x| x[1] == y })) > 0 // год
        am := arr_holiday[iy,2]
        if (im := ascan(am, {|x| x[1] == m })) > 0 // месяц
            fl := ( ascan(am[im,2],d) == 0 ) // не в массиве выходных
        endif
    endif
    return fl

// 20.01.23 проверяем дату во вхождение в период, допустимо пустое значение конечной даты
function correct_date_dictionary(dt, date_begin, date_end)

  return ((date_begin <= dt) .and. (empty(date_end) .or. date_end >= dt))

// 26.07.23
function between_date_new(_begin_date, _end_date, date1)
  local fl := .f.

  DEFAULT date1 TO sys_date  // по умолчанию проверяем на сегодняшний момент
  if empty(_begin_date) .and. empty(_end_date)
    return fl
  endif

  if ! empty(_begin_date) .and. empty(_end_date) .and. (_begin_date < date1)
    fl := .t.
  endif

  if (! empty(_begin_date)) .and. (! empty(_end_date)) .and. (_begin_date <= date1) .and. (_end_date >= date1)
    fl := .t.
  endif
  
  return fl

// попадает ли date1 (диапазон date1-date2) в диапазон _begin_date-_end_date
Function between_date(_begin_date,_end_date,date1,date2, impossiblyEmptyRange)
  // _begin_date - начало действия
  // _end_date   - окончание действия
  // date1 - проверяемая дата
  // date2 - вторая дата диапазона (если = NIL, то проверяем только по date1)
  // impossiblyEmptyRange - если .t. пустой диапазон дат не допустим
  Local fl := .f., fl2

  // проверим на недопустимость пустого диапазона дат
  if ! hb_isnil( impossiblyEmptyRange ) .and. impossiblyEmptyRange
    if empty(_begin_date) .and. empty(_end_date)
      return fl
    endif
  endif

  DEFAULT date1 TO sys_date  // по умолчанию проверяем на сегодняшний момент
  if empty(_begin_date)
    _begin_date := stod("19930101")  // если начало действия = пусто, то 01.01.1993
  endif
  // проверка даты date1 на попадание в диапазон
  if (fl := (date1 >= _begin_date)) .and. !empty(_end_date)
    fl := (date1 <= _end_date)
  endif
  // проверка диапазона date1-date2 на пересечение с диапазоном
  if valtype(date2) == 'D'
    if (fl2 := (date2 >= _begin_date)) .and. !empty(_end_date)
      fl2 := (date2 <= _end_date)
    endif
    fl := (fl .or. fl2)
  endif
  return fl

////* 20.04.21 определить лицо старше указанного возраста
Function ageIsMoreThan(age, DOB, dataCalc)
  return count_years(DOB, dataCalc) >= age

////* 23.12.18 количество лет, месяцев и дней в строке
Function count_ymd(_mdate, _sys_date, /*@*/y, /*@*/m, /*@*/d)
  // _mdate    - дата для определения количества лет, месяцев и дней
  // _sys_date - "системная" дата
  Local ret_s := "", md := _mdate
  y := m := d := 0
  if !empty(_sys_date) .and. !empty(_mdate) .and. _sys_date > _mdate
    do while (md := addmonth(md,12)) <= _sys_date
      ++y
    enddo
    if y > 0 .and. correct_count_ym(_mdate,_sys_date)
      --y
    endif
    md := addmonth(_mdate,12*y)
    do while (md := addmonth(md,1)) <= _sys_date
      ++m
    enddo
    if m > 0 .and. correct_count_ym(_mdate,_sys_date,2)
      --m
    endif
    md := addmonth(_mdate,12*y+m)
    do while (md := md+1) <= _sys_date
      ++d
    enddo
    if !emptyall(y,m) .and. d > 0 // только не для новорожденного
      --d
    endif
  endif
  if y > 0
    ret_s := lstr(y)+" "+s_let(y)+" "
  endif
  if m > 0
    ret_s += lstr(m)+" "+mes_cev(m)+" "
  endif
  if d > 0
    ret_s += lstr(d)+" "+dnej(d)
  endif
  return rtrim(ret_s)
  
////* 23.12.18 определение количества месяцев по дате (возврат числа)
Function count_months(_mdate,_sys_date)
  // _mdate    - дата для определения количества лет
  // _sys_date - "системная" дата
  Local k := 0, s1, s2, md := _mdate
  if !empty(_sys_date) .and. !empty(_mdate) .and. _sys_date > _mdate
    do while (md := addmonth(md,1)) <= _sys_date
      k++
    enddo
    if k > 0 .and. correct_count_ym(_mdate,_sys_date,2)
      --k
    endif
  endif
  return k
  
////* 22.07.18 определение количества лет по дате (возврат числа)
Function count_years(_mdate,_sys_date)
  // _mdate    - дата для определения количества лет
  // _sys_date - "системная" дата
  Local k := 0, s1, s2, md := _mdate
  if !empty(_sys_date) .and. !empty(_mdate) .and. _sys_date > _mdate
    do while (md := addmonth(md,12)) <= _sys_date
      k++
    enddo
    if k > 0 .and. correct_count_ym(_mdate,_sys_date)
      --k
    endif
  endif
  return k
  
////* 14.06.13 определение количества лет по дате (возврат строки)
Function ccount_years(_mdate,_sys_date)
  // _mdate    - дата для определения количества полных лет
  // _sys_date - "системная" дата
  Local ret_s := "", y
  if (y := count_years(_mdate, _sys_date)) > 0
    ret_s := lstr(y)+" "+s_let(y)
  endif
  return ret_s
  
////* 23.12.18 лицо считается достигшим определённого возраста не в день рождения, а начиная со следующих суток
Function correct_count_ym(_mdate,_sys_date,y_m)
  Local s1 := right(dtos(_mdate),4), s2 := right(dtos(_sys_date),4), fl := .f.
  DEFAULT y_m TO 1
  if s1 == s2 // проверяем равенство дня и месяца
    fl := .t.
  elseif s1 == "0229" .and. s2 == "0228" .and. !IsLeap(_sys_date) //_mdate - високосный год, а _sys_date - нет
    fl := .t.
  elseif y_m == 2 .and. right(s1,2) == right(s2,2) // проверяем равенство дня (для опр-ия кол-ва месяцев)
    fl := .t.
  endif
  return fl

////* 28.07.16 обновить системную дату (для работающих по ночам травмпунктов)
Function change_sys_date()
  sys_date := DATE()
  sys1_date := sys_date
  c4sys_date := dtoc4(sys1_date)
  return NIL
  